---
title: This protocol update is going to be Legen... wait for it...
authors: [gagdiez]
slug: yield-resume
tags: [protocol, updates]
hide_table_of_contents: true
---

*dary! Legendary! The protocol is getting updated with the ability to yield and resume computations*

<p><img src="https://img.freepik.com/free-photo/ancient-books-adorn-library-carefully-arranged-with-classics-rare-gems_157027-2332.jpg" /></p>

<!-- truncate -->

## The Problem
Currently, smart contracts have no way to halt execution and await the completion of a process. This can be a problem when you need to wait for an external event - i.e. coming from outside the blockchain - before continuing with the computation.

So far, one common workaround for this has been to make the contract call itself again and again, checking on each iteration to see if the result is ready. While each call delays the result by one block (~1 second), this method is not ideal as it can easily run out of gas before the result is ready.

To solve this issue, a new feature is being released that allows developers to **yield and resume computations in the protocol**.

## Yield and Resume
Starting from version `1.40`, developers will be able to delay executing a [callback function](/build/smart-contracts/anatomy/crosscontract#callback-method) until a certain condition is met.

Indeed, `yield` and `resume` will work as a delayed version of cross-contract calls. Lets see how it works:

> TODO: Explain this using a diagram instead of text

#### Cross-contract call

- The user calls the method `A` on `contract-A`
- The method `A` creates two promises: 
  1. To call the method `B` on `contract-B`
  2. To call the method `callback` on `contract-A` (itself)
- The method `B` of `contract-B` executes and finishes
- The method `callback` of `contract-a` executes and returns a value
- The value is sent to the user

#### Yield and Resume

- The user calls the method `A` on `contract-A`
- The method `A` creates a yield/resume condition: 
  > The method `resume-execution` will execute when somebody triggers `resume` using the id `yield-id`
- An external service calls `B` on `contract-A`, passing some arguments
  - The method `B` checks the arguments and executes `resume(yield-id, value)`
- The method `resume-execution` of `contract-A` executes and returns a value
- The value is sent to the user


## Instead of calling yourself, just wait

Lets see how this new feature can be used to avoid the recursive calling problem.

`Here goes a diagram showing how the "call oneself and check for result" is replaced by "yield and resume"`